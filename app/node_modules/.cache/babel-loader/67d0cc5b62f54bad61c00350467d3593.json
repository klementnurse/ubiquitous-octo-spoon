{"ast":null,"code":"import axios from 'axios';\nimport Qs from 'qs';\nimport config from './config';\nimport globalState from './globalState';\n/**\n * Cuts all api requests over to the api proxy in cloudfront. This is called when the client app can not establish\n * a connection with the production api for reasons out of our control such as blacklisting, extensions blocking,\n * tls issues.\n *\n * This is a circuit breaker approach and once triggered, the fallback domain will be used for the remainder\n * of the session.\n */\n\nexport var fallbackToApiProxy = function fallbackToApiProxy() {\n  axios.defaults.baseURL = \"https://dd8e7oi3be60r.cloudfront.net\";\n};\nexport var initAxios = function initAxios() {\n  axios.defaults.baseURL = config.apiUrl;\n  axios.defaults.withCredentials = true;\n  axios.defaults.timeout = config.requestTimeout;\n\n  axios.defaults.paramsSerializer = function (params) {\n    return Qs.stringify(params, {\n      arrayFormat: 'indices'\n    });\n  };\n\n  axios.interceptors.request.use(function (config) {\n    if (globalState.noCache) {\n      if (!config.params) {\n        config.params = {};\n      }\n\n      config.params.noCache = 1;\n    }\n\n    if (globalState.accessToken) {\n      config.headers['Authorization'] = \"Bearer \".concat(globalState.accessToken);\n    }\n\n    return config;\n  }, function (error) {\n    console.error('Request error', error);\n    return Promise.reject(error);\n  });\n  axios.interceptors.response.use(function (config) {\n    return config;\n  }, function (error) {\n    if (!error.response || error.response.status >= 500) {\n      console.error(error);\n      return Promise.reject(error);\n    }\n\n    return Promise.reject(error);\n  });\n};","map":{"version":3,"sources":["/Users/matthew/Desktop/optizmo/webapp/app/src/initAxios.ts"],"names":["axios","Qs","config","globalState","fallbackToApiProxy","defaults","baseURL","initAxios","apiUrl","withCredentials","timeout","requestTimeout","paramsSerializer","params","stringify","arrayFormat","interceptors","request","use","noCache","accessToken","headers","error","console","Promise","reject","response","status"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,EAAP,MAAe,IAAf;AAEA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,WAAP,MAAwB,eAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,GAAM;AACtCJ,EAAAA,KAAK,CAACK,QAAN,CAAeC,OAAf;AACD,CAFM;AAIP,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAY,GAAM;AAC7BP,EAAAA,KAAK,CAACK,QAAN,CAAeC,OAAf,GAAyBJ,MAAM,CAACM,MAAhC;AACAR,EAAAA,KAAK,CAACK,QAAN,CAAeI,eAAf,GAAiC,IAAjC;AACAT,EAAAA,KAAK,CAACK,QAAN,CAAeK,OAAf,GAAyBR,MAAM,CAACS,cAAhC;;AAEAX,EAAAA,KAAK,CAACK,QAAN,CAAeO,gBAAf,GAAkC,UAAUC,MAAV,EAAkB;AAClD,WAAOZ,EAAE,CAACa,SAAH,CAAaD,MAAb,EAAqB;AAAEE,MAAAA,WAAW,EAAE;AAAf,KAArB,CAAP;AACD,GAFD;;AAIAf,EAAAA,KAAK,CAACgB,YAAN,CAAmBC,OAAnB,CAA2BC,GAA3B,CACE,UAAAhB,MAAM,EAAI;AACR,QAAIC,WAAW,CAACgB,OAAhB,EAAyB;AACvB,UAAI,CAACjB,MAAM,CAACW,MAAZ,EAAoB;AAClBX,QAAAA,MAAM,CAACW,MAAP,GAAgB,EAAhB;AACD;;AACDX,MAAAA,MAAM,CAACW,MAAP,CAAcM,OAAd,GAAwB,CAAxB;AACD;;AACD,QAAIhB,WAAW,CAACiB,WAAhB,EAA6B;AAC3BlB,MAAAA,MAAM,CAACmB,OAAP,CAAe,eAAf,qBAA4ClB,WAAW,CAACiB,WAAxD;AACD;;AACD,WAAOlB,MAAP;AACD,GAZH,EAaE,UAAAoB,KAAK,EAAI;AACPC,IAAAA,OAAO,CAACD,KAAR,CAAc,eAAd,EAA+BA,KAA/B;AACA,WAAOE,OAAO,CAACC,MAAR,CAAeH,KAAf,CAAP;AACD,GAhBH;AAmBAtB,EAAAA,KAAK,CAACgB,YAAN,CAAmBU,QAAnB,CAA4BR,GAA5B,CACE,UAAAhB,MAAM,EAAI;AACR,WAAOA,MAAP;AACD,GAHH,EAIE,UAAAoB,KAAK,EAAI;AACP,QAAI,CAACA,KAAK,CAACI,QAAP,IAAmBJ,KAAK,CAACI,QAAN,CAAeC,MAAf,IAAyB,GAAhD,EAAqD;AACnDJ,MAAAA,OAAO,CAACD,KAAR,CAAcA,KAAd;AACA,aAAOE,OAAO,CAACC,MAAR,CAAeH,KAAf,CAAP;AACD;;AAED,WAAOE,OAAO,CAACC,MAAR,CAAeH,KAAf,CAAP;AACD,GAXH;AAaD,CAzCM","sourcesContent":["import axios from 'axios'\nimport Qs from 'qs'\n\nimport config from './config'\nimport globalState from './globalState'\n\n/**\n * Cuts all api requests over to the api proxy in cloudfront. This is called when the client app can not establish\n * a connection with the production api for reasons out of our control such as blacklisting, extensions blocking,\n * tls issues.\n *\n * This is a circuit breaker approach and once triggered, the fallback domain will be used for the remainder\n * of the session.\n */\nexport const fallbackToApiProxy = () => {\n  axios.defaults.baseURL = `https://dd8e7oi3be60r.cloudfront.net`\n}\n\nexport const initAxios = () => {\n  axios.defaults.baseURL = config.apiUrl\n  axios.defaults.withCredentials = true\n  axios.defaults.timeout = config.requestTimeout\n\n  axios.defaults.paramsSerializer = function (params) {\n    return Qs.stringify(params, { arrayFormat: 'indices' })\n  }\n\n  axios.interceptors.request.use(\n    config => {\n      if (globalState.noCache) {\n        if (!config.params) {\n          config.params = {}\n        }\n        config.params.noCache = 1\n      }\n      if (globalState.accessToken) {\n        config.headers['Authorization'] = `Bearer ${globalState.accessToken}`\n      }\n      return config\n    },\n    error => {\n      console.error('Request error', error)\n      return Promise.reject(error)\n    }\n  )\n\n  axios.interceptors.response.use(\n    config => {\n      return config\n    },\n    error => {\n      if (!error.response || error.response.status >= 500) {\n        console.error(error)\n        return Promise.reject(error)\n      }\n\n      return Promise.reject(error)\n    }\n  )\n}\n"]},"metadata":{},"sourceType":"module"}